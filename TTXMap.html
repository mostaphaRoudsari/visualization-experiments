<!DOCTYPE html>
<meta charset="utf-8">
<style>

    path  {
          stroke: black;
          stroke-width: 0.5px;
          fill: #cccccc;
        }

    svg {
      font: 10px sans-serif;
    }

    .worldmap
      {
        stroke-width: .1em;
      }

    .graphs {
      "background-color: "red";
    }

    .new_users {
      fill: #636363; /*#80b1d3;*/
      clip-path: url(#clip);
    }

    .existing_users {
      fill: #969696; /*#fb8072;*/
      clip-path: url(#clip);
    }

    .dark_line
      {
        stroke: black;
        stroke-width: .15em;
        fill: none;
      }

    .usage_circles {
      fill: #8dd3c7;
      stroke: black;
      stroke-width: .12em;
    }

    .axis path,
    .axis line {
      fill: none;
      opacity: .5;
      stroke: #cccccc; /*#fff;*/
      shape-rendering: crispEdges;
    }

    .context_border {
      fill: none;
      stroke: black;
      stroke-width :.1em;
      shape-rendering: crispEdges;
    }
    
    .brush .extent {
      stroke: black;
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }

    /* overlay rectangle for focus area */
    .overlay {
      fill: none;
      pointer-events: all;
    }

    .datalinegroup text {
                  color : red;
                }

    /* This classes are for page layout*/
          html,
          body {
            margin:0;
            padding:0;
            height:68%;
          }

          .wrapper {
                min-height:100%;
                position:relative
              }

          .map {
                /* padding-bottom:.2em;   /* Height of the footer element */
                font-family : Courier New;
                font-size: 3em;
                text-align:center; /* Center Horrizontally */
                position: absolute; /* Center Vertically */
                  top: 50%;
                  left: 50%;
                  margin-right: -50%;
                  transform: translate(-50%, -50%);
                  transition: font-size 1s;
              }
              
          .graphs {
              width:100%;
              height:.5em; /* Height of the footer element */
              position:absolute;
              bottom:0; 
              /*left:0;
              font: normal 11px Arial;*/
              }
</style>

<body>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v0.min.js"></script>
    <script>


    var locationData = [
        {"name":"Abu Dhabi","location":{"latitude":24.466667,"longitude":54.36666700000001}},
        {"name":"Beijing","location":{"latitude":39.904211,"longitude":116.407395}},
        {"name":"Boston","location":{"latitude":42.3581,"longitude":-71.0636}},
        {"name":"Chicago","location":{"latitude":41.8369,"longitude":-87.6847}},
        {"name":"Christchurch","location":{"latitude":-43.5300739,"longitude":172.6389998}},
        {"name":"Dallas","location":{"latitude":32.8665702,"longitude":-96.7683897}},
        {"name":"Denver","location":{"latitude":39.7618,"longitude":-104.8811}},
        {"name":"Fort Lauderdale","location":{"latitude":26.1333,"longitude":-80.1500}},
        {"name":"Ho Chi Minh City","location":{"latitude":10.8230989,"longitude":106.6296638}},
        {"name":"Hong Kong","location":{"latitude":22.2867465,"longitude":114.213349}},
        {"name":"Irvine","location":{"latitude":33.6774642,"longitude":-117.8554483}},
        {"name":"Kansas City","location":{"latitude":39.0997,"longitude":-94.5783}},
        {"name":"London","location":{"latitude":50.6395473,"longitude":-3.3932782}},
        {"name":"Los Angeles","location":{"latitude":34.0500,"longitude":-118.2500}},
        {"name":"Moscow","location":{"latitude":55.8242728,"longitude":37.4327742}},
        {"name":"Mumbai","location":{"latitude":19.0098653,"longitude":72.8355775}},
        {"name":"New York","location":{"latitude":40.7431194,"longitude":-73.9860597}},
        {"name":"Newark","location":{"latitude":40.7242,"longitude":-74.1726}},
        {"name":"Philadelphia","location":{"latitude":39.9500,"longitude":-75.1667}},
        {"name":"Portland","location":{"latitude":43.6667,"longitude":-70.2667}},
        {"name":"San Diego","location":{"latitude":32.7506835,"longitude":-117.1720953}},
        {"name":"San Francisco","location":{"latitude":37.3906114,"longitude":-122.0787303}},
        {"name":"Shanghai","location":{"latitude":31.235646,"longitude":121.482571}},
        {"name":"Sao Paulo","location":{"latitude":-23.5592401,"longitude":-46.6591607}},
        {"name":"Washington","location":{"latitude":38.8951,"longitude":-77.0456373}},
        {"name":"Dubai","location":{"latitude":24.9500,"longitude": 55.333}}]

    var updatedLocationData = []

    var widthInset = 50,
        totalHeight =420,
        totalWidth = window.innerWidth - widthInset;

    var margin = {top: .5 * totalHeight, right: 10, bottom: totalHeight/5, left: 40},
        margin2 = {top: .9 * totalHeight, right: 10, bottom:0.04* totalHeight, left: 40},
        width = totalWidth - margin.left - margin.right,
        height = totalHeight - margin.top - margin.bottom,      // height for focus area
        height2 = totalHeight - margin2.top - margin2.bottom;   // height for brushing area

    // code related to world map data
    var projection = d3.geo.mercator()
        .center([-0, -25])
        .scale(250)
        .rotate([-5,0]);


    var world_path = d3.geo.path()
        .projection(projection);


    // code related to graphs
    var parseDate = d3.time.format("%Y-%m-%d").parse,      // parse date based on input structure. In this example the structure is January 2010
        bisectDate = d3.bisector(function(d) { return d.date; }).left; // bisect data based on date

    var x = d3.time.scale().range([0, width]),          // x axis is time and this function scales it based on the width
        x2 = d3.time.scale().range([0, width]),         // similar to x
        y = d3.scale.linear().range([height, 0]),       // create scale for y axis
        y2 = d3.scale.linear().range([height2, 0]);

    var xAxis = d3.svg.axis().scale(x).orient("bottom"),
        xAxis2 = d3.svg.axis().ticks(25).scale(x2).orient("bottom"),
        yAxis = d3.svg.axis().scale(y).tickSize(-width).orient("left"); // YAxis for focus area

    var brush = d3.svg.brush()
        .x(x2)
        .on("brush", brushed); // when brush happens run brushed function - here all the interactive magic happens


    var new_users_focus_area = d3.svg.area() // new users
        .interpolate("step")
        .x(function(d) { return x(d.date); })
        .y0(height)
        .y1(function(d) { return y(d.new_users); });


    var new_and_returning_users_focus_area = d3.svg.area() // returning  users
        .interpolate("step")
        .x(function(d) { return x(d.date); })
        .y0(function(d) { return y(d.new_users); }) // start from where new_users height is
        .y1(function(d) { return y(d.existing_users + d.new_users); });
    	
    	
    var new_users_brush_area = d3.svg.area() // new users small area
        .interpolate("step")
        .x(function(d) { return x2(d.date); })
        .y0(height2)
        .y1(function(d) { return y2(d.new_users ); });

    var new_and_returning_users_brush_area = d3.svg.area() // returning  users small area
        .interpolate("step")
        .x(function(d) { return x2(d.date); })
        .y0(function(d) { return y2(d.new_users); })
        .y1(function(d) { return y2(d.existing_users + d.new_users); });

    // Dark stroke on top of the users line
    var line = d3.svg.line()
        .interpolate("step")
        .x(function(d) { return x(d.date); })
        .y(function(d) { return y(d.existing_users + d.new_users); });


    function updateUsageNumbers(){
          // d is the latest selected data which has all the time steps
          //var startDate = x.domain()[0];
          //var endDate = x.domain()[1];

          var startDate = x.domain()[0];
          var endDate = x.domain()[1];

          // filter initial data
          var selectedData = initialData.filter(function(d){return d.date > startDate &&  d.date < endDate;});

          debugger
          // calculate initial usage for each location and add a new key for usage
          locationData.forEach(function(loc){
              // number of usage in each office
              var usage = 0;
              // for each time-step add up the number of transactions
              selectedData.forEach(function(j)
              { 
                //debugger
                  if ( loc.name in j.usage_data)
                    {
                      usage += j.usage_data[loc.name];
                    };
              });

              loc.usage = usage; // update usage number
              return loc;
              });

        };

    function getTotalUsageNumbers(){
          // d is the latest selected data which has all the time steps

          // calculate initial usage for each location and add a new key for usage
          locationData.forEach(function(loc){
              // number of usage in each office
              var usage = 0;
              // for each time-step add up the number of transactions
              initialData.forEach(function(j)
              {     
                if(loc.name in j.usage_data) usage += j.usage_data[loc.name];
              });

              loc.usage = usage; // update usage number
              return loc;
              });

        };

    // create a scale for circles so I can control the maximum radius size
    var max_radius = 25; 
    var rScale = d3.scale.linear().range([0, max_radius]);
    var opacityScale = d3.scale.linear().range([1, 0.7]); // change the opacity based on radius .4-.75
    opacityScale.domain([0, max_radius]);

    var update_usage_circle = function(){
          // update usage numbers for offices based on new time range
          updateUsageNumbers();
          
          // update circle radius based on updated numbers
          mapsvg.selectAll("circle")
              .data(locationData)
                  .attr("r", function(d){return rScale(d.usage) + 2;}) // scale them based on rScale, max is set to
                  .attr("fill-opacity", function(d){return opacityScale(rScale(d.usage)) ;}); // change the opacity based on radius .4-.75
          };


    // a simple tool-tip for now
    var tooltip = d3.select("body")
          .append("div")
          .style("position", "absolute")
          .style("z-index", "10")
          .style("font-size", "1.2em")
          .style("visibility", "hidden")
          .text("loading...");

    // add div and svg for world map
    var mapsvg = d3.select("body")
        .append("div")
          .attr("class", "wrapper")
        .append("div")
          .attr("class", "map")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);


    // add svg for graph to the btm of the page - This doesn't really work as expected
    // if I change the zoom of the page it goes crazy. I should double check style properties
    var graphsvg = d3.select("body .wrapper")
        .append("div")
          .attr("class", "graphs")
        .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
        /*
        .append("defs").append("clipPath") //clipping the svg chart which I have absolutly no idea how it works!
          .attr("id", "clip")
        .append("rect")
          .attr("width", width)
          .attr("height", height);
          */
    /*

    let's create the groups for worldmap, circles, and both graphs 
    I will add world map and circles under mapsvg and graphs under
    graphsvg

    */
    var mapgroup = mapsvg.append("g")
        .attr("class", "worldmap")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var circlegroup = mapsvg.append("g")
        .attr("class", "usage_circles")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var focus = graphsvg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var datalinegroup = graphsvg.append("g")
        .attr("class", "focusdataline")
        .style("display", "none");

    var context = graphsvg.append("g")
        .attr("class", "context")
        .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");
    /*


    /*
    we are set with the structure [or actually I hope that's the case] so let's draw the graphs
    */

    // draw world map first
    // d3.json("https://dl.dropboxusercontent.com/u/16228160/world-110m2.json", function(error, topology) {
    d3.json("./map_source_data/data/world-110m2.json", function(error, topology) {
                 
              mapgroup.selectAll("path")
                    .data(topojson.object(topology, topology.objects.countries).geometries)
                    .enter()
                      .append("path")
                      .attr("class","worldmap")
                      .attr("d", world_path);
              
       });


    // draw the graphs and also add circles

    //d3.json("https://dl.dropboxusercontent.com/u/16228160/ttx_data.json", function(error, data) {
    d3.json("./map_source_data/data/ttx_data.json", function(error, data) {
                
                // iterate over data and parse date data to d3 format
                data.forEach(function(d) {
                      d.date = parseDate(d.date);
                      d.new_users = +d.new_users;
                      d.existing_users = +d.existing_users;

                      return d;
                      });

                // sort data based on date so I can bisect data later
                data.sort(function(a, b) { return a.date - b.date; });


                // put all data in a global variable to I can access it when I draw
                // usage circles. I'm not sure if this is the best way of doing this
                // but since the data structure doesn't match locations I needed to
                // do this so I can re-calculate usage data for each time step
                initialData = data;
                
                // add usage circles. I feel this is so NOT D3 way of doing this
                // making the data global and do it like this doesn't sound right to me!
                // calculate usage for each office over the full period of time
                getTotalUsageNumbers();

                // set the domain for raduis scale so the maximum number of total usage will be
                // set to maximum radius
                rScale.domain([0, d3.max(locationData.map(function(d) { return d.usage; }))]);

                // bind location data to circles under circle group
                // the group is inside mapsvg
                circlegroup.selectAll("circle")
                    .data(locationData)
                    .enter()
                      .append("circle")
                      .attr("cx", function(d) {return projection([d.location.longitude, d.location.latitude])[0];})
                      .attr("cy", function(d) {return projection([d.location.longitude, d.location.latitude])[1];})
                      .attr("r", function(d){return rScale(d.usage) + 2;}) // if usage is 0 it still draws a small circle
                      .attr("fill-opacity", opacityScale.range()[1])
                      .attr("stroke", "black")
                      .on("mouseover", function(d){
                            var nodeSelection = d3.select(this)
                              .attr('fill', 'orange')
                              //.style('stroke-width', function(d){return 0.2 * rScale(d.usage);}) // change stroke width
                              .style('stroke-width', ".2em") // change stroke width
                            return tooltip
                                   .text(d.name + ": " + d.usage)
                                   .style("visibility", "visible");}) // make tooltip visibale + change the color
                      .on("mousemove", function(){
                          return tooltip
                                 .style("top", (event.pageY - 20)+"px")
                                 .style("left",(event.pageX + 20)+"px");})
                      
                      .on("mouseout", function(){
                          var nodeSelection = d3.select(this)
                              .attr('fill', '') // back to default
                              .style('stroke-width', '') // remove width
                              return tooltip.style("visibility", "hidden");});

                // update domains for scales
                x.domain(d3.extent(data.map(function(d) { return d.date; })));
                y.domain([0, d3.max(data.map(function(d) { return d.existing_users + d.new_users; }))]);
                x2.domain(x.domain());
                y2.domain(y.domain());

                // add objects to focus area

                // 01 - add area path for returning users
                focus.append("path")
                    .datum(data)
                    .attr("class", "existing_users")
                    .attr("d", new_and_returning_users_focus_area);
              	
                // 02 - add area path for new users
                focus.append("path")
                    .datum(data)
                    .attr("class", "new_users")
                    .attr("d", new_users_focus_area);

                focus.append("path")
                    .datum(data)
                    .attr("class", "dark_line")
                    .attr("d", line);
                
                /*
                datalinegroup.append("text")
                      .attr("class", "data_text")
                      .attr("x", 0)
                      .attr("y", -15) // text show up a little bit above chart area
                      .attr("dy", ".35em")
                      .attr("color", "red");

                datalinegroup.append("rect")
                    .attr("height", "20")
                    .attr("width", 26);

                datalinegroup.append("line")
                      .attr("x1", "0")
                      .attr("y1", "0")
                      .attr("x2", "50")
                      .attr("y3", "50");
                */

                focus.append("text") // just for now until I get damn divs fixed, then I will put them under datalineGroup
                      .attr("class", "data_text")
                      .attr("y", -18) // text show up a little bit above chart area
                      .attr("dy", ".35em")
                      .attr("fill", "red");

                focus.append("line")
                      .attr("class", "data_line")
                      .attr("stroke-width", ".1em")
                      .attr("stroke", "red")
                      .attr("shape-rendering", "crispEdges");
                
                focus.append("rect")
                    .attr("class", "overlay")
                    .attr("width", width)
                    .attr("height", height)
                    .on("mouseover", function() {datalinegroup.style("display", null); })
                    .on("mouseout", function() {datalinegroup.style("display", "none"); })
                    .on("mousemove", function(){
                       // find  x value for mouse inside the rectangle
                       var xLocation = x.invert(d3.mouse(this)[0]), // mouse x relative to this rectangle
                           i = bisectDate(data, xLocation, 1), // find the index for the date
                          d0 = data[i - 1], // find the closest date available
                          d1 = data[i],
                          d = xLocation - d0.date > d1.date - xLocation ? d1 : d0;
                       
                       focus.select(".data_text")
                          .text(d.date.toDateString() + ": #new users " + d.new_users + ", #returning users: " + d.existing_users)
                          .attr("x", d3.mouse(this)[0] + 2);

                       focus.select(".data_line")
                          .attr("x1", d3.mouse(this)[0])
                          .attr("x2", d3.mouse(this)[0])
                          .attr("y1", -20)
                          .attr("y2", height + 6);
                        
                        });


                // 03 - x axix for focus area
                focus.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);

                // 04 - y axix for focus area
                focus.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);

                focus.append("g")
                      .attr("class", "focus text")
                      .append("text")
                        .attr("y", -5)
                        .text("Number of new and returning users.");

                // Do the same for the small chart and also add the brush here
                context.append("path")
                    .datum(data)
                    .attr("class", "existing_users")
                    .attr("d", new_and_returning_users_brush_area);

                context.append("path")
                    .datum(data)
                    .attr("class", "new_users")
                    .attr("d", new_users_brush_area);

                context.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height2 + ")")
                    .call(xAxis2);

                context.append("g")
                    .attr("class", "x brush")
                    .call(brush)
                  .selectAll("rect")
                    .attr("y", -6)
                    .attr("height", height2 + 7);

                // add a rectangle to have a border
                // and text to let visitors know what this thing is
                context.append("g")
                    .attr("class", "context_border")
                      .append("rect")
                        .attr("x", 0)
                        .attr("y", -6)
                        .attr("width", width)
                        .attr("height", height2 + 7)
                
                context.append("g")
                      .attr("class", "context text")
                      .append("text")
                        .attr("y", -10)
                        .text("Brush inside the rectangle below to select the time range.");
        });

  /*  
    // return data for that point of time
    function focuslinemousemove() {
        var x0 = x.invert(d3.mouse(this)[0]),
            i = bisectDate(data, x0, 1),
            d0 = data[i - 1],
            d1 = data[i],
            d = x0 - d0.date > d1.date - x0 ? d1 : d0;
        focus.attr("transform", "translate(" + x(d.date) + "," + y(d.close) + ")");
        focus.select("text").text(formatCurrency(d.close));
  */
  
    // zoom and pan for world map and circles
    var zoom = d3.behavior.zoom()
        .on("zoom",function() {
          mapsvg.selectAll("g").attr("transform","translate("+ 
            d3.event.translate.join(",")+")scale("+d3.event.scale+")");
      });

    mapsvg.call(zoom)

    // brushed event functions
    function brushed() {
        x.domain(brush.empty() ? x2.domain() : brush.extent());
        focus.select(".dark_line").attr("d", line);
        focus.select(".new_users").attr("d", new_users_focus_area);
        focus.select(".existing_users").attr("d", new_and_returning_users_focus_area);
        focus.select(".x.axis").call(xAxis);
        update_usage_circle();
    }

</script>